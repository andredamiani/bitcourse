= Capitolo 2

= Blockchain e Bitcoin: cosa sono e quali sono gli elementi che li definiscono

== Chiave Pubblica, Chiave Privata e Firma Digitale

In Bitcoin viene usata la crittografia a chiave pubblica per la generazione di una coppia di chiavi composta da una chiave pubblica e una privata. La chiave pubblica viene utilizzata per ricevere fondi e può essere paragonata al numero di un conto in banca; la chiave privata serve per firmare le transazioni e spendere i fondi rappresentando l’analogo del PIN che permette di controllare il conto.

La chiave privata consiste in un numero particolarmente elevato che deve essere assolutamente calcolato in maniera *casuale*. A partire da esso, utilizzando una funzione crittografica non invertibile, ovvero la moltiplicazione su curve ellittiche, viene generata la chiave pubblica. Da quest’ultima, utilizzando un’altra funzione crittografica non invertibile, una funzione di hash, viene generato un indirizzo bitcoin. La conoscenza di una chiave privata è alla base del controllo su tutti i fondi associati al corrispondente indirizzo, per tale ragione deve essere calcolata in maniera del tutto random e mantenuta segreta senza il rischio di perderla. La chiave privata è utilizzata per la creazione delle firme necessarie per dimostrare la proprietà dei bitcoin che si vuole spendere.
Il motivo per cui viene utilizzata la crittografia asimmetrica (chiave pubblica/privata) risiede nel fatto che rende possibile per ciascuno verificare la firma su ogni transazione, garantendo che solo chi possiede le chiavi private possa fornire delle firme valide.

Come già accennato, il punto fondamentale nella creazione delle chiavi è trovare una fonte sicura di entropia o casualità; di fatto creare una chiave privata equivale essenzialmente a prendere un numero tra 1 e 2^256^, pertanto il modo in assoluto più sicuro di farlo sarebbe quello di tirare una moneta 256 volte, ottenendo la rappresentazione binaria della chiave stessa. La dimensione dello spazio delle chiavi private bitcoin, 2^256^, è un numero incredibilmente grande, circa 10^77^ in notazione decimale, paragonabile al numero degli atomi dell’universo visibile (stimati essere nell’ordine dei 10^80^).

La chiave pubblica è calcolata a partire dalla chiave privata utilizzando la moltiplicazione su curve ellittiche, che è irreversibile: K = k * G, dove k è la chiave privata e, G è una costante chiamata _punto generatore_ e K è la chiave pubblica risultante. L’operazione inversa, conosciuta come _problema dei logaritmi finiti_ (calcolare k conoscendo K), è difficile tanto quanto provare tutti i possibili valori di k. Questo strumento matematico è la base per firme digitali sicure e non soggette a contraffazione che provino la proprietà dei fondi in bitcoin.

Un indirizzo bitcoin è una stringa di numeri e lettere che può essere condivisa con chiunque voglia inviarci del denaro; è quanto comunemente appare in una transazione come destinatario dei fondi. Esso viene ricavato dalla chiave pubblica attraverso un “algoritmo di hash” non invertibile che produce un’impronta digitale o “hash” di un input di qualsiasi dimensione. Quindi *un indirizzo bitcoin non coincide con una chiave pubblica*.

Lo scopo delle firme digitali è simile a quello delle firme scritte a mano: garantiscono che un messaggio sia stato generato da chi lo firma, non possono essere alterate e chi le utilizza non può negare di averlo fatto. Il protocollo di _firma digitale_ si compone di due parti, un algoritmo a chiave pubblica, che fornisce l’algoritmo matematico asimmetrico sottostante, e uno schema di _firma digitale_ che propone un modo di  utilizzare questo algoritmo asimmetrico per arrivare ad una _firma digitale_ funzionante.
Come visto poco sopra, vi è una chiave privata corrispondente a ciascuna chiave pubblica e di conseguenza a ciascun indirizzo bitcoin. Le chiavi pubbliche possono essere interpretate come numeri di conti bancari, mentre le chiavi private come le firme che possono sbloccare i conti. Per spendere i bitcoin, la transazione che autorizza la spesa deve essere firmata con la chiave privata.
Un punto tecnico in merito alle firme digitali è che il messaggio potrebbe essere di lunghezza arbitraria e questo può essere un problema poiché gli algoritmi implementati dalla crittografia a chiave pubblica sono lenti. La soluzione è quella di prendere l’hash del messaggio e di firmare questo invece del messaggio originale. L’output di una funzione di hash è sempre della stessa (più corta) lunghezza, indipendentemente dalla grandezza dell’input.
Per firmare un messaggio deve essere generato un _nonce_, ovvero un _numero random effimero_ usato una sola volta per ciascuna chiave privata. E’ essenziale che questo nonce non sia più riutilizzato, altrimenti sarebbe come rendere nota la propria chiave privata e quindi buttare via i propri fondi bitcoin.

== Transazioni

Una transazione dice al network che il proprietario di alcuni bitcoin ha autorizzato il loro trasferimento ad un altro proprietario, il quale, a sua volta, potrà spenderli creando una nuova transazione che autorizzi un secondo trasferimento e così via in una catena di proprietà. I bitcoin pertanto esistono in quanto riportati sulla blockchain, dove non sono presenti i conti e i saldi di chi li possiede, ma solamente le transazioni che li  spostano da un proprietario ad un altro.

Una transazione può essere creata con ogni mezzo, anche offline, e può essere propagata al network anche attraverso un canale non sicuro; i nodi la validano prima di propagarla ulteriormente.
Ogni transazione è composta da una lista di input (_TxIn_), che sono come debiti nei confronti di un conto bitcoin, e di output (_TxOut_), i quali sono come crediti aggiunti ad un conto bitcoin. Ogni output contiene un importo e l’indirizzo al quale è destinato; solamente chi può accedere a quell’indirizzo è in grado di  disporre dei bitcoin ad esso corrispondenti. Ciascun input, invece, contiene un riferimento all’output precedente (in questo modo le transazioni sono tra loro legate ed è possibile ripercorre la storia di ciascuna moneta) e la _firma digitale_ che autorizza la spesa dei relativi _TxOut_; la firma deve essere fatta con la chiave privata associata alla chiave pubblica dalla quale è stato ricavato l’indirizzo Bitcoin. In questi termini, “spendere” dei bitcoin significa firmare una transazione che trasferisca valore da una transazione precedente ad nuovo proprietario identificato da un indirizzo bitcoin.

Fra tutte le possibili transazioni ve ne è una particolare, _coinbase transaction_, che non contiene nessun input, ma solamente un output rappresentante la “ricompensa” per il miner per primo è riuscito a validare tutte le transazioni di un blocco includendolo nella Blockchain.

Una transazione raggruppa più _TxIn_ e _TxOut_ con lo scopo di redistribuire i fondi dei primi verso i secondi. Gli input si riferiscono sempre ad output precedenti, i quali non devono essere già stati spesi precedentemente perché la transazione sia valida. Infatti uno dei controlli che vengono eseguiti prima di validare una transazione è proprio la verifica che gli output che si vogliono spendere non siano già stati spesi in precedenza, in modo da evitare quello che viene definito come _double spending_. Si intuisce inoltre facilmente come sia necessario che la somma degli importi dei _TxIn_ sia maggiore o uguale alla somma dei _TxOut_. La differenza tra i due importi rappresenta una _fee_ che verrà riscossa da chi per primo riuscirà ad includere la transazione nella blockchain.

Un output deve essere speso completamente; se l’importo degli output è maggiore dell’importo da spendere, viene generato un _change_, ovvero un output aggiuntivo che viene indirizzato a chi sta spendendo i _TxOut_ della transazione. Concretamente si tratta di qualcosa di analogo al resto che si riceve in un tradizionale acquisto con gli euro in moneta o banconota; l’indirizzo utilizzato non coincide con nessuno degli indirizzi da cui provengono gli output in modo da garantire una maggiore privacy.

Una transazione contiene al suo interno una variabile denominata _lock time_, inoltre ogni input è associato ad un _sequence number_. Una transazione è ritenuta definitiva quando viene raggiunto il suo _lock time_ oppure quando  i _sequence number_ di tutti i suoi input sono impostati sul massimo valore possibile (dipendente dalla piattaforma, i.e. 32 bit oppure 64 bit). Il _lock time_ originariamente permetteva di mandare una transazione che potesse essere sostituita in un secondo momento, esprimendo il numero di blocchi (se inferiore a 500000000) o la data in formato Unix (se superiore a 500000000) prima del quale la transazione non poteva ritenersi definitiva. Perché una transazione possa essere sostituita almeno uno dei suoi input deve avere _sequence number_ inferiore al massimo. Versioni successive della transazione possono essere trasmesse con valori dei _sequence number_ più elevati. In questo modo una transazione può essere modificata dalle parti coinvolte prima di essere pubblicata sulla blockchain. Transazioni per le quali non è ancora stato raggiunto il _lock time_ oppure i cui _sequence number_ non sono impostati sul massimo valore possibile vengono definite _unfinalised transaction_s e non vengono incluse nella blockchain, ma scartate dai nodi che le ricevono.

Una volta che una transazione viene inviata al network, il primo nodo che la riceve verifica che sia valida, in caso affermativo, il nodo la propaga al resto della rete. Per verificare che una transazione sia valida, un nodo segue i tre step seguenti:

* Verifica che sia definitiva (non bloccata da _lock time_ e avente tutti i _sequence number_ valorizzati al massimo).
* Controlla che esistano gli output precedenti a cui gli input della transazione fanno riferimento e che non siano ancora stati spesi. I nodi conducono tale verifica consultando l’insieme degli output non ancora spesi presenti delle transazioni presenti sulla blockchain (_UTXO set_).
* Verifica che la somma dei valori in input sia maggiore di quelli in output; la differenza tra i due importi viene considerata come _fee_ lasciata al miner e viene inclusa nella _coinbase transaction_.
* Controlla che le firme di ciascun input siano valide, ovvero che ogni input  sia firmato con la chiave privata corrispondente alla chiave pubblica associata all’indirizzo a cui si riferisce.

Il software Bitcoin mantiene l’insieme di tutti gli output non ancora spesi (_UTXO set_), in modo che sia facile verificare la validità di una transazione, in quanto tale struttura occupa molto meno spazio dell’intera blockchain e può essere gestita dalla RAM. *Si può quindi affermare che i bitcoin in circolazione siano gli output non spesi delle transazioni presenti sulla blockchain*. Inoltre, essendo ciascun _UTXO_ nella blockchain è inalterabile e non può essere speso a meno che venga presentato un _TxIn_ che soddisfi le condizioni richieste, rimuovendolo così dall’_UTXO set_.

Finora abbiamo assunto che gli output siano inviati ad un indirizzo Bitcoin, in realtà il protoccollo è molto più flessibile: ogni _TxOut_ contiene un puzzle matematico che deve essere risolto per poter spendere l’importo in bitcoin associato. Il puzzle per sbloccare i fondi e la realtiva soluzione sono rappresentati da due script. Il primo è quello che crea il puzzle e viene denominato < _scriptPubKey_ > poiché nella sua versione più semplice contiene la chiave pubblica; il secondo, che sblocca i fondi, è chiamato < _scriptSig_ > in quanto contiene la firma associata all’indirizzo al quale sono stati inviati i bitcoin ed è contenuto all’interno dei _TxIn_.

== Consenso distribuito e Proof Of Work

Il vero grande successo del protocollo *Bitcoin* è quello di aver dato vita ad un sistema elettronico di pagamenti *peer-to-peer*, sicuro e affidabile, che non richiede fiducia in una Autority centrale, ma fondato su un algoritmo di consenso distribuito. Questo traguardo è stato possibile grazie alla *Blockchain*, un registro pubblico, distribuito e inalterabile, contenente la storia di tutte le transazioni.

Un sistema centralizzato sarebbe infatti esposto a diversi rischi. La presenza di un unico agente alla base dell'intero ecosistema comporta una fragilità intrinseca, il cosiddetto *Single Point of Failure*: l'ente centrale ha il potere di alterare o censurare i dati presenti nel registro.

I rischi derivanti da questo accentramento possono essere superati solo attraverso una ridistribuzione del potere dell'Autority. Tuttavia in questo contesto sorge una ulteriore difficoltà: ogni individuo che partecipa alla rete ha la possibilità di scrivere all'interno del registro. Come è possibile garantire che tale registro sia univoco e accettato da tutti? Tale criticità può essere ricondotta a quella formalizzata per la prima volta da Marshall Pease, Robert Shostak e Leslie Lamport nel 1982 e nota con il nome di *"Problema dei Generali Bizantini"*.

Nel loro articolo, link:http://research.microsoft.com/en-us/um/people/lamport/pubs/byz.pdf[*The Bizantine Generals Problem*], gli autori immaginano una situazione in cui diversi generali di un esercito devono decidere la strategia di attacco potendo comunicare tra di loro solo attraverso dei messaggeri. Tra di essi potrebbero esserci dei traditori. Per la buona riuscita dell'attacco è necessario che i generali si accordino su un univoco piano di azione e che un numero esiguo di traditori non possa alterarne il risultato.

L'analogia con la rete *peer-to-peer* utilizzata nel protocollo Bitcoin risiede proprio nella necessità di trovare un consenso univoco sulle transazioni da scrivere nella Blockchain, impedendo ai nodi che agiscono in modo scorretto di alterare la storia delle transazioni.

La soluzione proposta da Satoshi Nakamoto è basata sul fornire un incentivo di natura economica.

== Mining

== Funzioni di Hash e strutture dati Blockchain

La lettura della presente sezione permetterà di rendere chiaro il perchè della seguente affermazione:

****
_“Se si volesse cambiare un dato nella blockchain si dovrebbe applicare  un potere computazionale pari a tutto quello speso dal momento in cui il dato è stato inserito fino al presente. Inoltre dovrebbe essere superato il resto del network Bitcoin che continua ad aggiungere nuove righe al database distribuito”._
****

Una *funzione di hash* è un algoritmo che riceve in ingresso dati di lunghezza arbitraria e restituisce una stringa di lunghezza prefissata denominata *hash value*. L’hash value è il medesimo a parità di input utilizzato e piccole differenze nell’input producono grandi differenze nell’output. Essendo l’insieme di partenza molto più grande di quello di arrivo, più dati in ingresso condivideranno lo stesso hash value. Una buona funzione di hash dovrebbe distribuire i valori in input verso gli hash value in maniera proporzionale, in modo che ogni output sia approssimativamente legato allo stesso numero di valori di input.

Bitcoin utilizza le *funzioni di hash crittografiche* che richiedono dei requisiti aggiuntivi rispetto alle normali funzioni di hash:

* *Collision resistance*: è computazionalmente irrealizzabile trovare due input che risultino avere lo stesso hash value.
* *Hiding*: dato un hash value, deve essere computazionalmente irrealizzabile il relativo dato di input.
* *Puzzle friendliness*: se parte dell’input è scelto in un’opportuna maniera casuale è computazionalmente irrealizzabile trovare la restante parte in modo che l’output sia un determinato hash value.

Bitcoin usa in particolare la funzione _SHA256_, i cui output sono lunghi 256 bit.
Computazionalmente irrealizzabile significa che non vi è algoritmo conosciuto che possa recuperare l’input a partire dall’output in un tempo polinomiale rispetto alla dimensione dell’input. Ad oggi i migliori algoritmi usano la forza bruta e richiedono un tempo esponenziale.

Si intuisce come un hash value possa essere utilizzato per dimostrare che un documento non sia stato alterato oppure che sia esistito, poiché risulterebbe “impossibile” trovare un altro input che restituisca lo stesso output.

Un *hash pointer* è un puntatore a dove è memorizzata una certa informazione insieme all’hash value crittografico dell’informazione stessa effettuato in un determinato momento nel tempo. In aggiunta ad un normale puntatore, oltre a permettere di recuperare l’informazione, consente di verificare che non sia stata modificata.
La prima struttura che si può pensare di costruire è una linked list utilizzando gli hash pointer, che chiameremo *block chain*. Rispetto ad una normale linked list, i tradizionali puntatori sono sostituiti con degli hash pointer, in modo che ogni blocco non solo ci dica dove si trovi il valore precedente, ma contenga anche “l’impronta digitale” del valore, in modo da poter verificare che non sia stato alterato. A questo punto basta memorizzare l’inizio della lista, ovvero l’hash pointer che punta al blocco di dati più recente.

Per comprendere la ragione per cui una block chain non possa essere manomessa, si consideri cosa accade se si tenti di farlo. Lo scopo di un attacco è quello di modificare i dati in essa contenuti senza che la persona che ricordi l’hash pointer che punta all’inizio della catena possa accorgersene. Se viene modificato un dato nell’_n-esimo_ blocco, l’hash pointer presente nel _n+1-esimo_ blocco non è più corretto, in quanto rappresenta l’hash value dell’intero blocco _n_ prima della modifica. Questo discende direttamente dalla proprietà di _collision resistance_. A questo punto l’attaccante può anche modificare l’hash pointer del blocco _n+1_, ma questa modifica si ripercuoterebbe sul blocco seguente, dove l’hash pointer conterrebbe un hash value non corrispondente. In questo modo si raggiungerebbe il primo blocco della catena e se l’hash pointer che vi punta è memorizzato in un luogo sicuro, dove l’attaccante non possa modificarlo, qualunque manomissione della block chain sarebbe dunque individuata. Si rende evidente quindi come memorizzare un singolo hash pointer equivalga a memorizzare un hash value dell’intera lista. Il primo blocco all’interno della block chain viene denominato *genesis block*.

Un’altra struttura utile che può essere costruita tramite gli hash pointer è un albero binomiale, che viene denominato *Merkle tree*. Preso un certo numero di blocchi contenenti dei dati e che costituiscono le foglie dell’albero, questi vengono raggruppati in coppie e per ciascuna coppia viene creata una struttura con due hash pointer, ciascuno che punta ad un elemento della coppia, creando così il livello successivo dell’albero. A questo punto si raggruppano questi elementi a due a due e per ogni coppia si crea una nuova struttura contenente gli hash pointer di ciascuna delle precedenti strutture. Si procede in questo modo fino a raggiungere un singolo blocco, la radice dell’albero. Anche in questo secondo esempio di struttura, se venisse modificato un valore all’interno di un blocco in fondo all’albero, l’hash pointer del livello superiore non conterrebbe più l’hash value del dato a cui fa riferimento. Pur modificando tutti gli hash pointer fino alla cima dell’albero, se la radice è memorizzata in un luogo sicuro, ogni manomissione alla struttura sarebbe facilmente individuata. La memorizzazione dell’hash pointer presente nella radice dell’albero è dunque sufficiente per garantire che qualsiasi modifica si cerchi di effettuare ad uno dei dati venga anche scoperta.

Come anticipato all’inizio della sezione, si può ora comprendere perché modificare un dato all’interno della blockchain richieda tutto il potere computazionale speso dall’inserimento del dato fino al presente. La manipolazione di un dato in un certo blocco porta con sé la necessità di modificare tutti i blocchi successivi, in quanto contengono un hash pointer al blocco precedente; poiché ogni blocco ha richiesto del lavoro per essere minato, lo stesso lavoro deve essere svolto per poterlo modificare. Inoltre, si dovrebbe avere la gestione di quasi tutto il network Bitcoin, per impedire nel mentre che nuovi blocchi vengano aggiunti, incrementando il numero di quelli da modificare.

= Approfondimenti

== Algebra modulare e curve ellittiche

Alla base della struttura crittografica utilizzata dal network Bitcoin vi un oggetto matematico molto interessante, le *curve ellittiche*. Per comprendere come venga utilizzato in tutta la sua semplicità ed eleganza, è necessario introdurre prima un altro concetto matematico, l’*algebra modulare*.

Osservando il movimento di un orologio durante la giornata, è evidenza comune che la stessa posizione delle lancette sia visibile sempre in due momenti, ad esempio all’una e alle tredici, e che la differenza tra questi due momenti sia sempre di 12 ore; se considerassimo più giornate, avremmo che la differenza fra due posizioni identiche delle lancette sarebbe sempre un multiplo di 12. Si introduce così in maniera intuitiva il concetto di _congruenza modulo n_, per cui due numeri _a_ e _b_ sono congrui l’uno all’altro modulo _n_ se la loro differenza è divisibile per _n_. Due o più numeri che godano tra di loro di questa proprietà costituiscono una _classe di resto modulo n_. Tornando all’esempio iniziale, 13 è congruo a 1 modulo 12 (formalmente scritto 13 ≡ 1 mod _n_), poiché 13 - 1 = 12 è divisibile per 12, quindi sia 1 che 13 appartengono alla classe di resto 1 modulo 13, che contiene, per dirla in un altro modo, tutti e soli i numeri la cui divisione per 12 ha come resto 1.
Anche con le classi di resto si possono fare le operazioni abituali dei numeri interi, con alcune accortezze. Consideriamo ad esempio le congruenze modulo 7, si ha:

* 4 + 3 = 7 il cui resto nella divisione per 7 è 0, pertanto 3 è l’inverso di 4 rispetto all’addizione;
* 4 * 2 = 8 il cui resto nella divisione per 7 è 1, pertanto 2 è l’inverso di 4 rispetto alla moltiplicazione;
* 4 = 2 * 2 e 4 = 5 * 5 modulo 7, pertanto sia 2 che 5 sono radici quadrate di 4 (rispettivamente la radice pari e quella dispari, la cui somma meravigliosamente fa esattamente 7, come per ogni coppia di radici nelle classi di resto modulo 7).

Una *curva ellittica* viene definita come l’insieme dei punti _P = (x, y)_ che rendono vera un’equazione della forma _y^2^ = x^3^ + ax + b_ (equazione di Weierstrass). Di seguito, a titolo di esempio, viene raffigurata la curva _y^2^ = x^3^ + 2x + 3_:

image:images\1.png["Curva Ellittica"]

In crittografia non interessano i numeri reali, ma gli interi modulo un numero primo _p_, quindi l’equazione di Weierstrass viene considerata su un diverso insieme, quello appunto degli interi modulo questo numero _p_:

_y^2^ = x^3^ + a ⋅ x + b_ mod _p_.

Un’operazione è definita sull’insieme di punti che appartengono alla curva così definita e viene chiamata _Point Addition_:

_P3 = P1 + P2_.

Questa addizione gode delle seguenti proprietà geometriche:

Se i due punti sono differenti tra loro, l’operazione disegna una retta passante per essi che interseca la curva in un terzo punto. Il risultato finale è la riflessione di questo punto rispetto all’asse _x_.



Se i due punti coincidono, la retta del punto precedente è tangente alla curva e il risultato dell’operazione è la riflessione dell’intersezione della retta con la curva. Questa operazione viene chiamata _Point Doubling_.



Un interessante risultato riguardante le curve ellittiche è che i punti appartenenti la curva sopra definita formano un *gruppo abeliano* (esiste l’elemento neutro e l’inverso rispetto alla somma per ciascun elemento, inoltre invertendo l’ordine degli addendi il risultato non varia). Il gruppo è composto inoltre da un numero finito di elementi ed è *ciclico*: partendo da un punto iniziale sulla curva, chiamato *generatore*, e sommandolo successivamente, tutti i punti del gruppo vengono raggiunti. L’elemento neutro del gruppo viene chiamato _punto all’infinito_, nomenclatura che deriva dalla sua costruzione geometrica illustrata nell’immagine sottostante:

_P + ∞ = P_ +
_P + (- P) = ∞_



Dato un punto _P_ sulla curva ellittica e un intero _d_, la *point multiplication* è definita come il punto _T_ sulla curva ellittica ottenuto come risultato dell’addizione di _P_ a se stesso _d_ volte:

_T = d ⋅ P = P + P + … + P_.

L’operazione del *logaritmo discreto* è l’inverso della point multiplication, ovvero il logaritmo discreto di _T_ rispetto a _P_ è quell’intero _d_ tale che _T = d ⋅ P_. La point multiplication è un’operazione veloce utilizzando l’algoritmo *double-and-add*. Si tratta di un procedimento ricorsivo, che riduce il calcolo di _d ⋅ P_ a pochi point addition e point dubling, risultando essere polinomiale nel numero di bit di _d_, mentre quello del logaritmo discreto è irrealizzabile richiedendo un tempo esponenziale nei bit di _d_. Di seguito viene riportato un esempio, insieme con il codice Python dell’algoritmo:

_d = 947 = 2^0^ [blue]#\+# 2^1^ [blue]#+# 2^4^ [blue]#\+# 2^5^ [blue]#+# 2^7^ [blue]#\+# 2^8^ [blue]#+# 2^[red]+++9+++^_ +
_947P = P + 2P + 16P + 32P + 128P + 256P + 512P_

[red]#*9*# doubling e [blue]#*6*# addition: polinomiale nel numero di bit di _d_ e decisamente migliore di 946 addizioni

....
def pointMultiply(n, P):
   if n==1:
      return P
   elif n%2==1: # addition when n is odd
      return pointAdd(P, pointMultiply(n-1, P))
   else: # doubling when n is even
      return pointMultiply(n/2, pointDouble(P))
....

Nella prossima figura viene rappresentato un esempio del gruppo generato dalla curva ellittica _y^2^ = x^3^ + 2x + 3_ mod _263_, prendendo come punto generatore _A = (200, 39)_. Il secondo punto della curva è dunque dato da _A + A = 2A_, il terzo punto da _A + A + A = 3A_ e così via. Vi sono 270 punti nel gruppo, il primo grafico li mostra tutti, il secondo solamente i primi 14, ciascuno legato al precedente e al successivo. Geometricamente, formano un _pattern_ difficile da prevedere sul quadrato _(263, 263)_.





Scegliere i parametri di una curva ellittica da utilizzare (i coefficienti della curva, _a_ e _b_, l’ordine primo del campo, _p_, e il generatore, _A_) è un compito non banale. Vi sono diversi standard che determinano tali parametri, aventi lo scopo della sicurezza; Satoshi Nakamoto ha scelto lo standard *secp256k1* per Bitcoin.
Il miglior algoritmo che si conosca per risolvere il problema del logaritmo discreto sulle curve ellittiche necessita di un numero di passi proporzionali a _2^n/2^_, dove _n_ è il numero di bit della chiave; secp256k1 utilizza chiavi a 256 bit, quindi il numero di passi necessari è nell’intorno dei 2^128^, un numero decisamente più che astronomico.

L’*Elliptic Curve Digital Signature Algorithm (ECDSA)* è la combinazione delle curve ellittiche con DSA (digital signature scheme), lo schema di firma utilizzato in Bitcoin. I paramteri della curva, _a_ e _b_, l’ordine primo del campo, _p_, e il generatore, _A_, sono scelti secondo lo standard secp256k1. Dati questi parametri, l’ordine del gruppo ciclico composto dai punti della curva, _q_, è dato dal Teorema di Hasse. Per prima cosa si genera la chiave privata scegliendo un numero intero casuale _d_ minore di _q_. Va sottolineata l’importanza che _d_ sia scelto da un buon generatore di numeri casuali.
La parte dell’algoritmo che genera le chiavi calcola la chiave pubblica _B_ a partire da quella privata _d_ utilizzando _B = d ⋅ A_ mod _p_, dove _A_ è il generatore del gruppo. Questo passo è veloce utilizzando l’algoritmo _double-and-add_.

Per firmare un messaggio, innanzitutto viene generato un *ephemeral random number* _k~E~_. Sarà fra breve evidente l’importanza che sia casuale e utilizzato una sola volta, ovvero _k~E~_ è un *nonce*. La firma consiste in una coppia formata da due interi _(r, s)_, dove _r_ è la prima coordinata del punto _R = k~E~ ⋅  A_ appartenente alla curva ellittica, mentre s viene calcolato nel modo seguente:

_s = (H(m) + d ⋅ r)k~E~^-1^_ mod _q_

dove _m_ è il messaggio, _H(m)_ l’hash value del messaggio e _k~E~^-1^_ l’inverso moltiplicativo di _k~E~_. L’hashing è importante per ottenere un valore minore di _q_. La coppia _(r, s)_ viene pubblicata come la firma.

Si consideri ora il caso in cui _k~E~_ venga utilizzato due volte per firmare un messaggio, si ottiene:

_s1 = (H(m1) + d ⋅ r)k~E~^-1^_	mod _q_ +
_s2 = (H(m2) + d ⋅ r)k~E~^-1^_ mod _q_

Sottraendo _s~1~_ e _s~2~_ si può ricavare _k~E~_:

_s1 - s2 = (H(m1) + d ⋅ r)k~E~^-1^ - (H(m2) + d ⋅ r)k~E~^-1^_ mod _q = (H(m1) - H(m2))k~E~^-1^_ mod _q_ +
⇒ _k~E~ = (H(m1) - H(m2)) / (s~1~ - s~2~)_ mod _q_.

Una volta trovato _k~E~_, si può calcolare _d_:

_d = (s1 ⋅ k~E~ - H(m1)) / r_ mod _q_.

Di conseguenza riutilizzare l’ephemeral random number _k~E~_ anche solo una volta equivale a dare via la propria chiave privata. Questo può essere problematico per un indirizzo Bitcoin, perché perdere la chiave privata  vuol dire perdere il controllo dei fondi contenuti in quell’indirizzo.
